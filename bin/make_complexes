#!/usr/bin/env python3

"""
Script to make features for a list of protein sequences
"""

import argparse
from Bio import SeqIO
from pathlib import Path
from datetime import date
from alphafold_ibex.alphafold_ibex import AlphafoldIbex
from typing import List
from Bio.SeqRecord import SeqRecord
import sys


def read_sequences(input:str) -> list:
    """
    Get an input of either a fasta file or a directory and read all the sequences
    in it
    """
    
    input = Path(input)
    
    if not input.exists():
        raise ValueError('Input file or directory does not exist.')
    
    if input.is_file():
        sequences = list(SeqIO.parse(input, 'fasta'))
    elif input.is_dir():
        sequences = []
        for f in input.glob('*.fasta'):
            sequences += list(SeqIO.parse(f, 'fasta'))
    else:
        raise ValueError('Input must be either a fasta file or a directory with fasta files.')
    
    return sequences


def get_id(seqid:str) -> str:
    """
    Process and return the id of the sequence

    Args:
        seqid (str): full id of the sequence

    Returns:
        str: processed id
    """
    names = seqid.split('|')
    
    if len(names) > 1:
        return names[1]
    else:
        return names[0]


def validate_models(models:list) -> list:
    """
    Validate the names of the models to be run
    """
    
    all_models = [
        'model_1_multimer_v3',
        'model_2_multimer_v3',
        'model_3_multimer_v3',
        'model_4_multimer_v3',
        'model_5_multimer_v3'
    ]
    
    if models == ['all']:
        return all_models
    elif models == ['two']:
        return ['model_3_multimer_v3','model_4_multimer_v3']
    else:
        # Check that the models are valid
        if not all([m in all_models for m in models]):
            raise ValueError('Invalid model names provided.')
        
        return models
        

def check_existing_features(features_dir: Path, bait: SeqRecord,
                            sequences: List[SeqRecord]) -> List[str]:
    """
    Check if the features for the bait and the candidates already exist

    Args:
        features_dir (Path)
        bait (SeqRecord)
        sequences (List[SeqRecord]): candidate sequences

    Raises:
        ValueError: Error if the features for the bait are not found

    Returns:
        List[str]: List of the ids of the candidate sequences that already have
                   features
    """
    
    print(f'Checking for existing features in {features_dir}...')
    
    # Features file for bait
    bait_id = get_id(bait.id)
    bait_features_file = features_dir / bait_id / 'features.pkl'
    if not bait_features_file.exists():
        raise ValueError(f'Features for bait {bait.id} not found in {features_dir}.')
    
    # Features files for candidates
    # all_ids = [s.id.split('|')[1] for s in sequences]
    all_ids = [get_id(s.id) for s in sequences]

    # Get the ids of the sequences that have a `features.pkl` file
    completed = []
    for sid in all_ids:
        features_file = features_dir / sid / 'features.pkl'
        if features_file.exists():
            completed.append(sid)
    
    print(f'Found {len(completed)} features for {len(sequences)} candidate sequences.')
    
    return completed

def check_missing_models(completed: List[str], out_dir: Path, bait: SeqRecord,
                          sequences: List[SeqRecord]) -> List[SeqRecord]:
    """
    Obtain the list of sequences that don't have a model yet

    Args:
        completed (List): List of ids of the sequences that have features
        out_dir (Path): Output directory for the models
        bait (SeqRecord): Bait sequence
        sequences (List[SeqRecord]): Candidate sequences

    Returns:
        List[SeqRecord]: List of candidate sequences that don't have a model yet
    """
    
    print(f"Checking for existing models in {out_dir}...")
    bait_id = get_id(bait.id)
    # Get the ids of the sequences that have a model already created
    modeled = []
    for sid in completed:
        model_scores = out_dir / f'{bait_id}-1_{sid}-1' / 'iptms.json'
        if model_scores.exists():
            modeled.append(sid)

    print(f'Found {len(modeled)} models for {len(sequences)} candidate sequences.')

    to_model = [s for s in completed if s not in modeled]

    # Get the sequences to model
    sequences_to_model = [s for s in sequences if get_id(s.id) in to_model]
    
    return sequences_to_model


def parsing(args: list=None) -> argparse.Namespace:
    """
    Creates the argument parser instance and applies it to the command line
    input

    Args:
        args (list, optional): List of the arguments to be parsed (only to be
            used for testing). If none is provided, it is taken from sys.argv.
            Defaults to None.

    Returns:
        argparse.Namespace
    """

    def validate_num(num:str):
        """
        Validate the number in the arguments for gpu, mem, time and recycles

        Args:
            num (str): Number provided
        """
        if num=='auto':
            return num
        
        return int(num)
    
    def validate_date(d:str):
        """
        Validate the date format

        Args:
            d (str): date in YYYY-MM-DD format

        Returns:
            str: same date if valid
        """
        dsplit = d.split('-')
        if len(dsplit) < 3:
            raise ValueError('Incorrect date format, please provide date as YYYY-MM-DD.')
        elif int(dsplit[1]) > 12:
            raise ValueError('Incorrect date format, please provide date as YYYY-MM-DD.')
        
        return d
    
    def validate_features_dir(d:str) -> Path:
        """
        Validate that the directory with the features exists
        """
        d = Path(d)
        if not d.exists():
            raise ValueError("The specified features directory doesn't exist.")
            
        return d
    
    def validate_bait(f:str) -> Path:
        """
        Validate that the bait file exists
        """
        f = Path(f)
        if not f.exists():
            raise ValueError("The specified bait file doesn't exist.")
        
        return f
    

    parser = argparse.ArgumentParser(description=('Takes one or more FASTA '
        'files with amino acid sequences, and submits a '
        'job array to ibex to make features for each sequence.'))
    
    parser.add_argument("--bait",
        help=("FASTA file with the sequence of the bait protein. This file must"
              " contain only ONE sequence."),
        type=validate_bait, required=True)

    parser.add_argument("--candidates", help=('Fasta file(s) with the sequence(s) '
        'to model as multimers againts the bait protein.'), nargs='+')
    
    parser.add_argument("--features_dir", 
        help=('Path with the pre-calculated features.'), required=True,
        type=validate_features_dir)

    parser.add_argument("--destination", 
        help=('Path for saving the resulting AlphaFold models. It will create '
        'one subdirectory for each model. Also will contain the sequence files ' 
        'as they were submitted to ibex, the script that was submitted and the '
        'ibex stdout files.'), required=True)
    
    parser.add_argument("--time", help=('Time in minutes to give to each job. '
        '(default=30)'), type=int, default=30)

    parser.add_argument("--mem", help=('Memory in GB to allocate to each job. '
        '(default="auto")'), type=validate_num, default='auto')

    parser.add_argument("--mail", help=('Email to send notifications about the '
                'job progess in ibex.'), type=str)
    
    parser.add_argument("--max_jobs",
        help=("Maximum number of jobs to submit simultaneously to ibex. Default=1990"),
        type=int, default=1990)
    
    parser.add_argument("--gpu_type", help=("Whether to use V100 or A100 GPU."
        " If you don't know what this is, leave the default. (Default=v100)"),
        default='v100', choices=['v100','a100'])
    
    parser.add_argument("--models_to_run",
        help=("Which of the AlphaFold models to run. Choose 'all' to make all five"
              " models, 'two' to make only two models with different parameters"
              ", or give the name(s) of the specific model(s) that you want to "
              "run separated by spaces. Default = 'two'."), nargs='+')
    
    parser.add_argument("--multimer_predictions_per_model", help=('Number of '
        'multimeric predictions to make for each of the ML models that '
        'AlphaFold runs.'), type=int, default=1)
    
    parser.add_argument("--old_uniclust",
        help=("If hhblits is causing an error along the lines of `ERROR: did "
              "not find ### match states in sequence 1 of ##########`, try "
              "using the older version of the UniClust database (UniRef30_2021_03) "
              "to calculate the MSAs with HHblits."), action='store_true')
    
    parser.add_argument("--max_template_date",
        help=('Maximum template release date to consider. Give value in '
              'YYYY-MM-DD format.'), type=validate_date,
        default=date.today().isoformat())
 
    return parser.parse_args(args)


if __name__ == '__main__':

    args = parsing()
    
    bait = SeqIO.read(args.bait, 'fasta')
    
    # Read all candidate sequences in every input file or directory and put together in a list
    sequences = []
    for f in args.candidates:
        sequences += read_sequences(f)
    
    print(f'Read {len(sequences)} candidate sequences to multimerize with bait.')
    
    ######### Check for existing features
    features_dir = Path(args.features_dir)
    
    completed = check_existing_features(features_dir, bait, sequences)
    
    ######### Check for existing models in the destination directory
    
    out_dir = Path(args.destination)
    
    if out_dir.exists():
        sequences_to_model = check_missing_models(completed, out_dir, bait,
                                                  sequences)
    else:
        out_dir.mkdir()
        sequences_to_model = sequences
        
    # Make complexes
    complexes = [[bait, s] for s in sequences_to_model]
    print(f'{len(complexes)} complexes to model.')
    
    ###### Get the rest of the parameters
    model_names = validate_models(args.models_to_run)

    # Save command to output dir
    with open(out_dir/'command.txt', 'w') as f:
        f.write(' '.join(sys.argv))
        f.write('\n')
    
    # Run AlphaFold
    print('Running AlphaFold to calculate complexes...')
    exe = AlphafoldIbex(complexes, out_dir=out_dir, jobname='AF_complexes',
                    models_to_relax='none',
                    multimer_predictions_per_model=args.multimer_predictions_per_model,
                    gpu_type=args.gpu_type,
                    screen_mode=True,
                    features_dir=features_dir,
                    mail=args.mail,
                    time_per_command=args.time,
                    mem=args.mem,
                    model_names=model_names)

    exe.run()
